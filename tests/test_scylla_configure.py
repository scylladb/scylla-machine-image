#
# Copyright 2020 ScyllaDB
#
# SPDX-License-Identifier: Apache-2.0
import base64
import json
import logging
import random
import shutil
import sys
import tempfile
import unittest.mock
from email.mime.base import MIMEBase
from email.mime.multipart import MIMEMultipart
from pathlib import Path
from textwrap import dedent
from unittest import TestCase

import yaml


sys.path.append(str(Path(__file__).parent.parent))

import pytest

from common.scylla_configure import ScyllaMachineImageConfigurator
from lib.log import setup_logging


LOGGER = logging.getLogger(__name__)


SNITCHS = ["GoogleCloudSnitch", "Ec2Snitch", "Ec2MultiRegionSnitch", "AzureSnitch", "GossipingPropertyFileSnitch"]


class DummyCloudInstance:
    ENDPOINT_SNITCH = random.choice(SNITCHS)

    def __init__(self, user_data, private_ipv4, region=None, availability_zone=None):
        self._user_data = user_data
        self.private_ip_v4 = private_ipv4
        self.region = region
        self.availability_zone = availability_zone

    def private_ipv4(self):
        return self.private_ip_v4

    @property
    def user_data(self):
        return self._user_data

    @property
    def endpoint_snitch(self):
        return self.ENDPOINT_SNITCH


class TestScyllaConfigurator(TestCase):
    def setUp(self):
        # Mock cloud detection to avoid file access issues when running on cloud VMs (e.g., GitHub Actions on Azure)
        self.patchers = [
            unittest.mock.patch("lib.param_estimation.is_ec2", return_value=False),
            unittest.mock.patch("lib.param_estimation.is_oci", return_value=False),
            unittest.mock.patch("lib.param_estimation.is_azure", return_value=False),
        ]
        for patcher in self.patchers:
            patcher.start()

        LOGGER.info("Setting up test dir")
        self.temp_dir = tempfile.TemporaryDirectory()
        self.temp_dir_path = Path(self.temp_dir.name)
        setup_logging(log_level=logging.DEBUG, log_dir_path=str(self.temp_dir_path))
        LOGGER.info("Test dir: %s", self.temp_dir_path)
        shutil.copyfile(Path(__file__).parent / "tests-data/scylla.yaml", str(self.temp_dir_path / "scylla.yaml"))
        self.private_ip = "172.16.16.1"
        self.configurator = ScyllaMachineImageConfigurator(scylla_yaml_path=str(self.temp_dir_path / "scylla.yaml"))
        self.test_cluster_name = "test-cluster"

    def tearDown(self):
        for patcher in self.patchers:
            patcher.stop()
        self.temp_dir.cleanup()

    def default_instance_metadata(self):
        return {"user_data": "", "private_ipv4": self.private_ip}

    def check_yaml_files_exist(self):
        assert self.configurator.scylla_yaml_example_path.exists(), "scylla.yaml example file not created"
        assert self.configurator.scylla_yaml_path.exists(), "scylla.yaml file not created"

    def run_scylla_configure(self, user_data, private_ipv4, region=None, availability_zone=None):
        self.configurator._cloud_instance = DummyCloudInstance(
            user_data=user_data, private_ipv4=private_ipv4, region=region, availability_zone=availability_zone
        )
        self.configurator.configure_scylla_yaml()

    @staticmethod
    def multipart_user_data(scylla_data, data_type):
        raw_user_data = json.dumps(scylla_data) if data_type == "json" else yaml.safe_dump(scylla_data)

        msg = MIMEMultipart()

        filename = f"scylla_machine_image.{data_type}"
        part = MIMEBase("x-scylla", data_type)
        part.set_payload(raw_user_data)
        part.add_header("Content-Disposition", f'attachment; filename="{filename}"')
        msg.attach(part)

        return msg

    def test_empty_user_data(self):
        self.run_scylla_configure(**self.default_instance_metadata())
        self.check_yaml_files_exist()
        with self.configurator.scylla_yaml_path.open() as scylla_yaml_file:
            LOGGER.info("Checking that defaults are set as expected...")
            scylla_yaml = yaml.load(scylla_yaml_file, Loader=yaml.SafeLoader)
            assert scylla_yaml["listen_address"] == self.private_ip
            assert scylla_yaml["broadcast_rpc_address"] == self.private_ip
            assert scylla_yaml["endpoint_snitch"] in self.configurator.cloud_instance.endpoint_snitch
            assert scylla_yaml["rpc_address"] == "0.0.0.0"
            assert scylla_yaml["seed_provider"][0]["parameters"][0]["seeds"] == self.private_ip
            assert "scylladb-cluster-" in scylla_yaml["cluster_name"], "Cluster name was not autogenerated"

    def test_user_data_params_are_set(self):
        ip_to_set = "172.16.16.84"
        raw_user_data = json.dumps(
            {
                "scylla_yaml": {
                    "cluster_name": self.test_cluster_name,
                    "listen_address": ip_to_set,
                    "broadcast_rpc_address": ip_to_set,
                    "seed_provider": [
                        {
                            "class_name": "org.apache.cassandra.locator.SimpleSeedProvider",
                            "parameters": [{"seeds": ip_to_set}],
                        }
                    ],
                }
            }
        )
        self.run_scylla_configure(user_data=raw_user_data, private_ipv4=ip_to_set)
        self.check_yaml_files_exist()
        with self.configurator.scylla_yaml_path.open() as scylla_yaml_file:
            scylla_yaml = yaml.load(scylla_yaml_file, Loader=yaml.SafeLoader)
            assert scylla_yaml["cluster_name"] == self.test_cluster_name
            assert scylla_yaml["listen_address"] == ip_to_set
            assert scylla_yaml["broadcast_rpc_address"] == ip_to_set
            assert scylla_yaml["seed_provider"][0]["parameters"][0]["seeds"] == ip_to_set
            # check defaults
            assert scylla_yaml["auto_bootstrap"] is True

    def test_postconfig_script(self):
        test_file = "scylla_configure_test"
        script = dedent(f"""
            touch {self.temp_dir_path}/{test_file}
        """)
        raw_user_data = json.dumps(
            {"post_configuration_script": base64.b64encode(bytes(script, "utf-8")).decode("utf-8")}
        )
        self.run_scylla_configure(user_data=raw_user_data, private_ipv4=self.private_ip)
        self.configurator.run_post_configuration_script()
        assert (self.temp_dir_path / test_file).exists(), "Post configuration script didn't run"

    def test_postconfig_script_with_timeout(self):
        test_file = "scylla_configure_test"
        script_timeout = 5
        script = dedent(f"""
            sleep {script_timeout}
            touch {self.temp_dir_path}/{test_file}
        """)
        raw_user_data = json.dumps(
            {
                "post_configuration_script": base64.b64encode(bytes(script, "utf-8")).decode("utf-8"),
                "post_configuration_script_timeout": script_timeout - 4.5,
            }
        )

        self.run_scylla_configure(user_data=raw_user_data, private_ipv4=self.private_ip)

        with pytest.raises(SystemExit):
            self.configurator.run_post_configuration_script()
        assert not (self.temp_dir_path / test_file).exists(), "Post configuration script didn't fail with timeout"

    def test_postconfig_script_with_bad_exit_code(self):
        script = dedent("""
            exit 84
        """)
        raw_user_data = json.dumps(
            {
                "post_configuration_script": base64.b64encode(bytes(script, "utf-8")).decode("utf-8"),
            }
        )
        self.run_scylla_configure(user_data=raw_user_data, private_ipv4=self.private_ip)
        with pytest.raises(SystemExit):
            self.configurator.run_post_configuration_script()

    def test_multipart_user_data_params_are_set(self):
        ip_to_set = "172.16.16.84"

        scylla_user_data = {
            "scylla_yaml": {
                "cluster_name": self.test_cluster_name,
                "listen_address": ip_to_set,
                "broadcast_rpc_address": ip_to_set,
                "seed_provider": [
                    {
                        "class_name": "org.apache.cassandra.locator.SimpleSeedProvider",
                        "parameters": [{"seeds": ip_to_set}],
                    }
                ],
            }
        }
        for data_type in ("json", "yaml"):
            msg = self.multipart_user_data(scylla_user_data, data_type)
            self.run_scylla_configure(user_data=str(msg), private_ipv4=ip_to_set)
            self.check_yaml_files_exist()
            with self.configurator.scylla_yaml_path.open() as scylla_yaml_file:
                scylla_yaml = yaml.load(scylla_yaml_file, Loader=yaml.SafeLoader)
                assert scylla_yaml["cluster_name"] == self.test_cluster_name
                assert scylla_yaml["listen_address"] == ip_to_set
                assert scylla_yaml["broadcast_rpc_address"] == ip_to_set
                assert scylla_yaml["seed_provider"][0]["parameters"][0]["seeds"] == ip_to_set
                # check defaults
                assert scylla_yaml["auto_bootstrap"] is True

    def test_do_not_start_on_first_boot(self):
        raw_user_data = json.dumps(
            {
                "start_scylla_on_first_boot": False,
            }
        )
        self.run_scylla_configure(user_data=raw_user_data, private_ipv4=self.private_ip)
        with unittest.mock.patch("subprocess.run"):
            self.configurator.start_scylla_on_first_boot()

    def test_default_raid0(self):
        self.run_scylla_configure(**self.default_instance_metadata())
        with unittest.mock.patch("subprocess.run") as mocked_run:
            self.configurator.create_devices()
            assert "--raid-level 0" in str(mocked_run.call_args)

    def test_set_raid0(self):
        raw_user_data = json.dumps({"raid_level": 0})
        self.run_scylla_configure(user_data=raw_user_data, private_ipv4=self.private_ip)
        with unittest.mock.patch("subprocess.run") as mocked_run:
            self.configurator.create_devices()
            assert "--raid-level 0" in str(mocked_run.call_args)

    def test_set_raid5(self):
        raw_user_data = json.dumps({"raid_level": 5})
        self.run_scylla_configure(user_data=raw_user_data, private_ipv4=self.private_ip)
        with unittest.mock.patch("subprocess.run") as mocked_run:
            self.configurator.create_devices()
            assert "--raid-level 5" in str(mocked_run.call_args)

    @unittest.mock.patch("common.scylla_configure.estimate_streaming_bandwidth", return_value=0)
    def test_cassandra_rackdc_for_gossipingpropertyfilesnitch(self, mock_bandwidth):
        """Test cassandra-rackdc.properties generation for GossipingPropertyFileSnitch."""
        region = "us-phoenix-1"
        az = "AD-2"

        # Set up user data with GossipingPropertyFileSnitch
        raw_user_data = json.dumps({"scylla_yaml": {"endpoint_snitch": "GossipingPropertyFileSnitch"}})

        self.run_scylla_configure(
            user_data=raw_user_data, private_ipv4=self.private_ip, region=region, availability_zone=az
        )

        # Run the cassandra-rackdc configuration
        # Mock the Path to write to our temp directory
        with unittest.mock.patch("common.scylla_configure.Path") as mock_path_cls:

            def path_side_effect(p):
                if "cassandra-rackdc.properties" in str(p):
                    return self.temp_dir_path / "cassandra-rackdc.properties"
                return Path(p)

            mock_path_cls.side_effect = path_side_effect
            self.configurator.configure_cassandra_rackdc()

        # Check that cassandra-rackdc.properties was created
        rackdc_path = self.temp_dir_path / "cassandra-rackdc.properties"
        assert rackdc_path.exists(), "cassandra-rackdc.properties was not created"

        # Check the content
        with rackdc_path.open() as rackdc_file:
            content = rackdc_file.read()
            assert f"dc={region}" in content, f"Expected dc={region} in cassandra-rackdc.properties"
            assert f"rack={az}" in content, f"Expected rack={az} in cassandra-rackdc.properties"

    @unittest.mock.patch("common.scylla_configure.estimate_streaming_bandwidth", return_value=0)
    def test_cassandra_rackdc_skipped_for_other_snitch(self, mock_bandwidth):
        """Test that cassandra-rackdc.properties is not generated for other snitches."""
        # Use Ec2Snitch
        raw_user_data = json.dumps({"scylla_yaml": {"endpoint_snitch": "Ec2Snitch"}})

        self.run_scylla_configure(
            user_data=raw_user_data, private_ipv4=self.private_ip, region="us-west-1", availability_zone="us-west-1a"
        )

        # Mock the rackdc path to our temp directory
        rackdc_path = self.temp_dir_path / "cassandra-rackdc.properties"
        with unittest.mock.patch("pathlib.Path") as mock_path:

            def path_side_effect(p):
                if "cassandra-rackdc.properties" in str(p):
                    return self.temp_dir_path / "cassandra-rackdc.properties"
                return Path(p)

            mock_path.side_effect = path_side_effect
            self.configurator.configure_cassandra_rackdc()

        # Check that cassandra-rackdc.properties was NOT created
        assert not rackdc_path.exists(), "cassandra-rackdc.properties should not be created for Ec2Snitch"
